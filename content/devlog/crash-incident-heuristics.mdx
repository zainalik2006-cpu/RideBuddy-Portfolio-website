---
title: "Crash/Incident Heuristics + False Positive Tests"
date: "2024-12-22"
tags: ["Event Detection", "Crash Detection", "Testing", "Signal Processing"]
summary: "Designing a crash detection heuristic that identifies impact events followed by stillness, and running controlled tests to minimize false positives."
status: "test"
---

## What I Built

The most important feature of RideBuddy: detecting when the rider has crashed. The system needs to distinguish a real crash from normal riding events like hitting a pothole, dropping the bike at a stop, or just parking.

The heuristic uses a two-phase pattern: **impact** followed by **stillness**.

## The Crash Pattern

A crash has a distinctive sensor signature:

1. **Impact phase**: Very high acceleration spike (>3g) across multiple axes, often with rapid rotation
2. **Stillness phase**: After the impact, the bike (and often the rider) comes to rest — very low acceleration variance and near-zero angular velocity

Normal riding never produces this combination. Hard braking has high decel but no stillness after. Potholes have spikes but no stillness. Parking has stillness but no impact.

## The Algorithm

```python
IMPACT_THRESHOLD = 3.0      # g (total magnitude)
STILLNESS_WINDOW = 5.0      # seconds after impact
STILLNESS_VAR_THRESHOLD = 0.05  # g² (variance of accel magnitude)
GYRO_STILL_THRESHOLD = 5.0  # °/s (max gyro magnitude)

def detect_crash(accel_mag, gyro_mag, timestamps):
    # Phase 1: Look for impact
    for i, a in enumerate(accel_mag):
        if a > IMPACT_THRESHOLD:
            impact_time = timestamps[i]
            impact_magnitude = a

            # Phase 2: Check for stillness in the window after impact
            still_start = impact_time + 1.0  # skip 1s post-impact chaos
            still_end = impact_time + STILLNESS_WINDOW

            still_accels = [
                accel_mag[j] for j, t in enumerate(timestamps)
                if still_start <= t <= still_end
            ]
            still_gyros = [
                gyro_mag[j] for j, t in enumerate(timestamps)
                if still_start <= t <= still_end
            ]

            if len(still_accels) < 100:  # need enough data
                continue

            accel_var = variance(still_accels)
            max_gyro = max(still_gyros) if still_gyros else 999

            if accel_var < STILLNESS_VAR_THRESHOLD and max_gyro < GYRO_STILL_THRESHOLD:
                return {
                    'type': 'crash',
                    'impact_time': impact_time,
                    'impact_magnitude': impact_magnitude,
                    'stillness_duration': still_end - still_start,
                    'confidence': compute_confidence(impact_magnitude, accel_var),
                }
    return None
```

<Callout type="note" title="Confidence Score">
The confidence score combines impact magnitude and stillness quality. A 5g impact followed by perfect stillness scores higher than a 3.1g impact with some residual movement. This helps in post-ride review — high confidence events get flagged prominently.
</Callout>

## False Positive Testing

I ran a series of controlled tests to verify the detector doesn't trigger on normal riding events:

### Test 1: Pothole Impact
Drove over a speed bump at 30 km/h. Peak acceleration: 2.4g. No stillness after.

**Result**: No false positive. Impact below threshold.

### Test 2: Hard Braking to Stop
Emergency stop from 50 km/h. Peak decel: 1.1g. Bike stopped (stillness present).

**Result**: No false positive. Deceleration well below 3g impact threshold.

### Test 3: Drop at Standstill
Intentionally tipped the bike over in a parking lot (on grass). Peak impact: 3.8g. Bike stayed on ground (stillness).

**Result**: **True positive** — this is a legitimate incident event. The system correctly detected it.

### Test 4: Aggressive Cornering
Multiple 40°+ lean angle corners. Peak lateral accel: 0.7g equivalent.

**Result**: No false positive. Normal cornering forces are well below the impact threshold.

### Test 5: Engine Vibration
Idling and revving at 8000 RPM. Vibration amplitude: ±0.3g at ~130Hz.

**Result**: No false positive. Vibration is high-frequency and low-amplitude, filtered by the EMA.

<Callout type="result" title="Test Summary">
5 tests, 0 false positives, 1 true positive (the intentional drop). The two-phase heuristic effectively separates crashes from all normal riding events tested so far.
</Callout>

<Callout type="warning" title="Limitations">
The current heuristic requires stillness after impact. A crash where the bike slides for an extended period before stopping could have a delayed detection. Also, a low-speed tip-over (e.g., feet down failure) might produce impact below 3g and be missed. These edge cases need more real-world testing.
</Callout>

## What I Learned

- The impact + stillness pattern is a strong discriminator for crash detection. The key insight is that crashes almost always end in stillness, while normal events don't.
- False positive testing is as important as true positive testing. A crash detector that triggers on every pothole is useless.
- Controlled testing is limited — you can't easily simulate a real high-speed crash. The heuristic will need calibration from real-world data over time.

## Next Steps

- Add an alert system (buzzer/LED) that triggers on crash detection with a cancellation window
- Log crash events with GPS location for emergency response potential
- Build a first-ride full integration test with all systems running
