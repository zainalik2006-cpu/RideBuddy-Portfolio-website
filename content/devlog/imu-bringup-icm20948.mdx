---
title: "IMU Bring-Up: ICM-20948 on Raspberry Pi"
date: "2024-10-15"
tags: ["IMU", "Raspberry Pi", "I2C", "Hardware"]
summary: "Getting the ICM-20948 9-axis IMU talking over I2C, reading accelerometer and gyroscope data, and validating output against gravity."
status: "done"
---

## What I Built

The first step in the RideBuddy pipeline: reading raw sensor data from the ICM-20948 9-axis IMU (accelerometer + gyroscope + magnetometer) connected to the Raspberry Pi 4 via I2C.

The goal was simple — get reliable, timestamped readings from all sensor axes at a consistent sample rate, and verify the data makes physical sense.

## Hardware Setup

The ICM-20948 breakout board connects to the Pi with four wires:

- **VCC** → 3.3V (Pin 1)
- **GND** → GND (Pin 6)
- **SDA** → GPIO2 (Pin 3)
- **SCL** → GPIO3 (Pin 5)
- **AD0** → 3.3V (sets I2C address to `0x69`)

After enabling I2C in `raspi-config`, a quick scan confirmed the device:

```
$ i2cdetect -y 1
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
60: -- -- -- -- -- -- -- -- -- 69 -- -- -- -- -- --
```

## Reading Data with Python

I used `smbus2` for direct register access. The ICM-20948 has a banked register system — Bank 0 for basic accel/gyro reads, Bank 2 for configuration.

```python
import smbus2
import struct
import time

bus = smbus2.SMBus(1)
ICM_ADDR = 0x69

def read_accel():
    data = bus.read_i2c_block_data(ICM_ADDR, 0x2D, 6)
    ax, ay, az = struct.unpack('>hhh', bytes(data))
    scale = 16384.0  # ±2g range
    return ax / scale, ay / scale, az / scale
```

<Callout type="note" title="Register Banks">
The ICM-20948 uses register bank switching (register `0x7F`). You need to select Bank 0 before reading sensor data and Bank 2 before changing configuration like sample rate or full-scale range.
</Callout>

## Validation

With the board sitting flat on my desk, I expected:

- **Accel X, Y** ≈ 0g
- **Accel Z** ≈ 1g (gravity)
- **Gyro X, Y, Z** ≈ 0°/s (no rotation)

The readings confirmed this within expected noise margins. I also rotated the board 90° to check axis orientation — each axis responded correctly.

<Callout type="result" title="Result">
Accelerometer reads within ±0.02g of expected gravity vector. Gyroscope zero-rate offset is ~1.5°/s, consistent with datasheet specs. Noise floor is acceptable for the complementary filter planned next.
</Callout>

## Sample Rate

At 100Hz (10ms sleep between reads), the Pi handles the I2C reads without dropped samples. CPU usage is under 5%. I log timestamps alongside each reading to verify timing consistency.

```python
while True:
    t = time.time()
    ax, ay, az = read_accel()
    gx, gy, gz = read_gyro()
    log_row(t, ax, ay, az, gx, gy, gz)
    time.sleep(0.01)
```

<Callout type="warning" title="Timing">
Python's `time.sleep()` isn't precise enough for hard real-time. Actual intervals vary ±2ms. For the current use case this is fine, but a future version might use a hardware timer or a C extension for tighter timing.
</Callout>

## What I Learned

- I2C on the Pi is straightforward with `smbus2`, but the ICM-20948's register bank system adds complexity. Good documentation from InvenSense helps.
- Always validate raw readings against known physical states before building anything on top of them.
- Timestamping matters — even at 100Hz, 2ms of jitter compounds if you're doing integration (gyro → angle).

## Next Steps

- Add magnetometer reads (Bank 0, registers `0x11–0x16`, requires I2C master config for the internal AK09916)
- Implement a basic complementary filter for orientation estimation
- Start GPS integration for position data
