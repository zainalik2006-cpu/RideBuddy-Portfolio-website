---
title: "GPS Logging + Timestamp Sync"
date: "2024-11-02"
tags: ["GPS", "Raspberry Pi", "UART", "Data Pipeline"]
summary: "Integrating the u-blox NEO-M8N GPS module via UART, parsing NMEA sentences, and synchronizing GPS time with IMU timestamps."
status: "done"
---

## What I Built

Added GPS position and velocity data to the telemetry pipeline. The u-blox NEO-M8N connects to the Raspberry Pi via UART and outputs standard NMEA sentences. I parse the relevant sentences, extract lat/lon/speed/course, and merge them into the same timestamped log as the IMU data.

The tricky part: the IMU runs at 100Hz and the GPS at 10Hz, on different clocks. Getting their timestamps aligned correctly is important for downstream fusion and event detection.

## Hardware Setup

The GPS module connects via UART:

- **VCC** → 5V (Pin 2)
- **GND** → GND (Pin 14)
- **TX** → GPIO15 / RXD (Pin 10)
- **RX** → GPIO14 / TXD (Pin 8)

I disabled the Pi's serial console in `raspi-config` and enabled the hardware UART. The GPS defaults to 9600 baud — I reconfigure it to 115200 and 10Hz update rate using UBX protocol commands on startup.

## NMEA Parsing

The GPS outputs several NMEA sentence types. I only need two:

- **`$GNGGA`** — position fix: lat, lon, altitude, fix quality, satellites
- **`$GNRMC`** — recommended minimum: lat, lon, speed (knots), course, date/time

```python
import serial

ser = serial.Serial('/dev/ttyAMA0', 115200, timeout=1)

def parse_gps():
    line = ser.readline().decode('ascii', errors='ignore').strip()
    if line.startswith('$GNRMC'):
        parts = line.split(',')
        if parts[2] == 'A':  # valid fix
            lat = nmea_to_decimal(parts[3], parts[4])
            lon = nmea_to_decimal(parts[5], parts[6])
            speed_knots = float(parts[7]) if parts[7] else 0
            return {
                'lat': lat, 'lon': lon,
                'speed_kmh': speed_knots * 1.852,
                'gps_time': parts[1],
                'gps_date': parts[9],
            }
    return None
```

<Callout type="note" title="Fix Quality">
The GPS takes 30–60 seconds for a cold start fix. For test rides, I power up the system a couple minutes early to ensure a valid fix before logging begins. The `$GNGGA` sentence's fix quality field tells you whether you have a valid position.
</Callout>

## Timestamp Synchronization

The core challenge: the IMU timestamps come from `time.time()` (system clock), and the GPS has its own atomic-referenced UTC time embedded in the NMEA sentences. These two clocks can drift apart.

My approach:

1. On each GPS fix, record both the system timestamp and the GPS UTC time
2. Compute the offset: `offset = system_time - gps_utc_epoch`
3. Apply this offset to all IMU timestamps retroactively
4. Re-compute offset every GPS update (10Hz) to track drift

```python
gps_epoch = parse_gps_datetime(gps_date, gps_time)
offset = time.time() - gps_epoch
# Apply: corrected_imu_time = imu_system_time - offset
```

<Callout type="warning" title="Drift">
Over a 20-minute ride, I measured up to 150ms of drift between the Pi's system clock and GPS UTC. This is significant if you're correlating events across IMU and GPS streams. The per-update offset correction handles this.
</Callout>

## Data Logging Format

I merge both streams into a single CSV with a common timestamp column:

```
timestamp,ax,ay,az,gx,gy,gz,lat,lon,speed_kmh,course
1698901234.123,0.02,-0.01,0.98,1.2,-0.5,0.1,,,
1698901234.133,0.03,-0.02,0.99,1.1,-0.4,0.2,,,
...
1698901234.200,0.02,-0.01,0.98,1.2,-0.5,0.1,37.7749,-122.4194,35.2,270.5
```

GPS rows fill in lat/lon/speed; IMU-only rows leave them blank. Downstream analysis interpolates GPS data to IMU timestamps when needed.

## What I Learned

- UART setup on the Pi requires disabling the serial console — otherwise Linux grabs the port.
- NMEA parsing is simple but full of edge cases: empty fields, invalid fixes, checksum errors. Always validate before using.
- Clock synchronization between heterogeneous sensors is a real problem. Even a "simple" system like Pi + GPS has measurable drift.

## Next Steps

- Implement interpolation for GPS data at IMU sample rate
- Start sensor fusion using combined accel + gyro + GPS heading
- Design the event detection pipeline
