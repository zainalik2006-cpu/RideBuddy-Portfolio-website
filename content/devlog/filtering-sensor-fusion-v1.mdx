---
title: "Filtering + Sensor Fusion v1"
date: "2024-11-20"
tags: ["Sensor Fusion", "Signal Processing", "IMU", "Python"]
summary: "Implementing a complementary filter to fuse accelerometer and gyroscope data into stable pitch and roll estimates for motorcycle lean angle tracking."
status: "done"
---

## What I Built

Raw accelerometer data is noisy and susceptible to vibration artifacts. Raw gyroscope data drifts over time. A complementary filter combines both: gyro for short-term orientation (fast, no noise) and accelerometer for long-term reference (slow, corrects drift).

The output: stable, real-time pitch and roll angle estimates — which translate directly to motorcycle lean angle.

## Why a Complementary Filter

There are fancier options (Kalman filter, Madgwick, Mahony), but for v1 I chose the complementary filter because:

- Simple to implement and debug
- Computationally cheap (runs easily at 100Hz on the Pi)
- Good enough for lean angle estimation within ±2°
- Easy to tune with a single parameter (alpha)

I can always upgrade to an extended Kalman filter later if the accuracy isn't sufficient.

## The Algorithm

The complementary filter blends gyro-integrated angles with accelerometer-derived angles:

```python
import math

alpha = 0.98  # trust gyro 98%, accel 2%
dt = 0.01     # 100Hz

pitch = 0.0
roll = 0.0

def update(ax, ay, az, gx, gy, gz):
    global pitch, roll

    # Gyro integration (degrees)
    pitch_gyro = pitch + gx * dt
    roll_gyro = roll + gy * dt

    # Accel reference (degrees)
    pitch_accel = math.degrees(math.atan2(ax, math.sqrt(ay**2 + az**2)))
    roll_accel = math.degrees(math.atan2(ay, math.sqrt(ax**2 + az**2)))

    # Blend
    pitch = alpha * pitch_gyro + (1 - alpha) * pitch_accel
    roll = alpha * roll_gyro + (1 - alpha) * roll_accel

    return pitch, roll
```

<Callout type="note" title="Alpha Tuning">
Higher alpha (closer to 1.0) trusts the gyro more — smoother output but slower drift correction. Lower alpha trusts the accelerometer more — noisier but no drift. I found 0.98 works well for motorcycle dynamics where lean changes are fast but not instantaneous.
</Callout>

## Low-Pass Filtering

Before feeding data into the complementary filter, I apply a simple exponential moving average (EMA) to the raw accelerometer to reduce high-frequency vibration noise:

```python
class EMA:
    def __init__(self, alpha=0.1):
        self.alpha = alpha
        self.value = None

    def update(self, x):
        if self.value is None:
            self.value = x
        else:
            self.value = self.alpha * x + (1 - self.alpha) * self.value
        return self.value
```

This removes engine vibration harmonics while preserving the lean angle signal.

## Validation

I tested by:

1. **Static**: Board flat → pitch/roll ≈ 0°. Tilted 45° with protractor → reads 44–46°.
2. **Rotation**: Slow 360° rotation around one axis — smooth curve, no jumps.
3. **Vibration**: Tapped the table rapidly — accel spikes, but fused output stays smooth.
4. **Sustained tilt**: Held at 30° for 2 minutes — no drift (accel correction working).

<Callout type="result" title="Accuracy">
Static accuracy within ±2° across the full range. Dynamic tracking tested against a phone's gyroscope showed agreement within ±3°. Drift is effectively zero over multi-minute windows thanks to the accel correction term.
</Callout>

## Performance

The filter runs at 100Hz with negligible CPU impact on the Pi 4. Total pipeline (read IMU + filter + log) uses about 8% of one core.

## What I Learned

- The complementary filter is surprisingly effective for its simplicity. The key insight is that accel and gyro errors are in different frequency bands, so blending them cancels both.
- Pre-filtering raw data matters. Without the EMA on the accelerometer, motorcycle vibration would bleed into the fused output.
- Testing against known angles (protractor, phone) catches calibration and sign errors early.

## Next Steps

- Add magnetometer for yaw / heading estimation
- Build the event detection layer on top of fused orientation data
- Consider upgrading to Madgwick filter if yaw accuracy becomes important
